<?php
 namespace App\Http\Controllers\Api; use App\Http\Controllers\Controller; use App\Http\Resources\WeekPatternCollection; use App\Http\Resources\WeekPatternResource; use App\Jobs\PruneOrphanWorkPatterns; use App\Models\WeekPattern; use App\Models\WorkPattern; use Exception; use Illuminate\Http\Request; use Illuminate\Support\Facades\DB; use Illuminate\Support\Facades\Validator; use Illuminate\Validation\Rule; use InvalidArgumentException; use Throwable; class WeekPatternController extends Controller { public function index(Request $request) { $perPage = (int) $request->input('per_page', 20); if ($perPage > 100) { $perPage = 100; } $weekPatterns = WeekPattern::with([ 'saturdayPattern', 'sundayPattern', 'mondayPattern', 'tuesdayPattern', 'wednesdayPattern', 'thursdayPattern', 'fridayPattern' ])->orderBy('name')->paginate($perPage); return new WeekPatternCollection($weekPatterns); } public function findOrCreateAtomicPattern(array $dayRule): int { if (!$dayRule['is_working_day']) { $attributes = [ 'type' => 'fixed', 'work_duration_minutes' => 0, 'start_time' => null, 'end_time' => null ]; $name = 'روز استراحت'; } else { $attributes = [ 'type' => 'fixed', 'start_time' => $dayRule['start_time'], 'end_time' => $dayRule['end_time'], 'work_duration_minutes' => $dayRule['work_duration_minutes'], ]; $name = "شیفت ثابت {$dayRule['start_time']}-{$dayRule['end_time']} ({$dayRule['work_duration_minutes']} دقیقه)"; } $workPattern = WorkPattern::firstOrCreate($attributes, [ 'name' => $name, ]); return $workPattern->id; } private function getDayColumnName(int $dayOfWeek): string { $map = [ 0 => 'saturday_pattern_id', 1 => 'sunday_pattern_id', 2 => 'monday_pattern_id', 3 => 'tuesday_pattern_id', 4 => 'wednesday_pattern_id', 5 => 'thursday_pattern_id', 6 => 'friday_pattern_id', ]; if (!isset($map[$dayOfWeek])) { throw new InvalidArgumentException("Invalid day_of_week value: $dayOfWeek"); } return $map[$dayOfWeek]; } private function validateRequest(Request $request, $ignoreId = null) { $nameRule = ['required', 'string', 'max:255']; if ($ignoreId) { $nameRule[] = Rule::unique('week_patterns')->ignore($ignoreId); } else { $nameRule[] = Rule::unique('week_patterns', 'name'); } return Validator::make($request->all(), [ 'name' => $nameRule, 'floating_end'=>'required|integer|min:0', 'floating_start'=>'required|integer|min:0', 'days' => 'required|array|size:7', 'days.*.day_of_week' => 'required|integer|between:0,6|distinct', 'days.*.is_working_day' => 'required|boolean', 'days.*.start_time' => 'required_if:days.*.is_working_day,true|nullable|date_format:H:i', 'days.*.end_time' => 'required_if:days.*.is_working_day,true|nullable|date_format:H:i|after:days.*.start_time', 'days.*.work_duration_minutes' => 'required_if:days.*.is_working_day,true|nullable|integer|min:0|max:1440', ]); } public function store(Request $request) { $validator = $this->validateRequest($request); if ($validator->fails()) { return response()->json(['errors' => $validator->errors()], 422); } $validatedData = $validator->validated(); $dayPatternIds = []; try { DB::beginTransaction(); foreach ($validatedData['days'] as $dayRule) { $patternId = $this->findOrCreateAtomicPattern($dayRule); $dayColumnName = $this->getDayColumnName($dayRule['day_of_week']); $dayPatternIds[$dayColumnName] = $patternId; } $weekPatternData = array_merge( [ 'name' => $validatedData['name'], 'floating_start' =>$validatedData['floating_start'], 'floating_end' => $validatedData['floating_end'], ], $dayPatternIds ); $weekPattern = WeekPattern::create($weekPatternData); DB::commit(); $weekPattern->load( [ 'saturdayPattern', 'sundayPattern', 'mondayPattern', 'tuesdayPattern', 'wednesdayPattern', 'thursdayPattern', 'fridayPattern' ]); return (new WeekPatternResource($weekPattern)) ->response() ->setStatusCode(201); } catch (Exception $e) { DB::rollBack(); return response()->json(['message' => 'Failed to create week pattern', 'error' => $e->getMessage()], 500); } } public function show(WeekPattern $weekPattern) { $weekPattern->load([ 'saturdayPattern', 'sundayPattern', 'mondayPattern', 'tuesdayPattern', 'wednesdayPattern', 'thursdayPattern', 'fridayPattern' ]); return new WeekPatternResource($weekPattern); } public function update(Request $request, WeekPattern $weekPattern) { $validator = $this->validateRequest($request,$weekPattern->id); if ($validator->fails()) { return response()->json(['errors' => $validator->errors()], 422); } $validatedData = $validator->validated(); $dayPatternIds = []; try { DB::beginTransaction(); foreach ($validatedData['days'] as $dayRule) { $patternId = $this->findOrCreateAtomicPattern($dayRule); $dayColumnName = $this->getDayColumnName($dayRule['day_of_week']); $dayPatternIds[$dayColumnName] = $patternId; } $weekPatternData = array_merge( [ 'name' => $validatedData['name'], 'floating_start' =>$validatedData['floating_start'], 'floating_end' => $validatedData['floating_end'], ], $dayPatternIds ); $weekPattern->update($weekPatternData); DB::commit(); $weekPattern->load( [ 'saturdayPattern', 'sundayPattern', 'mondayPattern', 'tuesdayPattern', 'wednesdayPattern', 'thursdayPattern', 'fridayPattern' ]); return new WeekPatternResource($weekPattern); } catch (Exception $e) { DB::rollBack(); return response()->json(['message' => 'Failed to update week pattern', 'error' => $e->getMessage()], 500); } } public function destroy(WeekPattern $weekPattern) { if ($weekPattern->workGroups()->exists() || $weekPattern->employees()->exists()) { return response()->json(['message' => 'Cannot delete this week pattern because it is assigned to one or more work groups or employees.'], 409); } $weekPattern->delete(); PruneOrphanWorkPatterns::dispatch(); return response()->json(null, 204); } } 